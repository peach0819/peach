-----------------------------前言
关系型数据库不能直接支持交集的计算，而redis天然支持，包含了对集合的交集、并集、差集操作
redis单机特性：事务、持久化、lua脚本、排序、二进制位操作
redis多机特性：复制、哨兵、集群

----------------------------第一部分、数据结构与对象 -----------------------------
--------------1、简单动态字符串（SDS） ，感觉类似varchar
redis的key（所有key都是string），string类型的value，都是SDS形式的

还有AOF模块的缓冲区、客户端状态中的输入缓冲区，都是SDS实现的

SDS的C语言内部实现是一个struct，包含了已使用字节数（字符串长度）、未使用字节数、字节数组（载体）
C语言的char[]，最后一位都是以'\0'结尾的，表示结束符，这个是不会算到length里面的

SDS的好处：
1）反复对一个字符串使用STRLEN 命令获取长度，也是O(1)的复杂度，因为记录下来了
2）避免缓冲区溢出，即字符串修改影响到了后续的内存的数据，SDS会检查空间是否充足，不够就扩容
3）二进制安全，因为整个字段都是固定的空间，长度通过length判断，而不是通过判断'\0'结尾

C语言的字符串反复变更会导致内存频繁重新分配
而SDS的free空间避免了这种缺陷，对此有两种策略：空间预分配、惰性空间释放
1）空间预分配：
case when 空间小于1MB then length*2 +1 （13字节的字符串，空间就是27）
        when 空间大于1MB then length + 1MB +1 （30MB的字符串，就是31MB + 1）
2）惰性空间释放：
字符串缩短的时候，不立即回收内存，而是把这部分空间变成free，等待将来使用

--------------2、链表
list类型的key，发布和订阅、慢查询、监视器等功能都用到了链表，
redis本身还用链表来保存多个客户端的状态信息

struct list实现包含了链表的头指针，尾指针，节点长度，
中间的每个节点都是一个双向链表节点，包含了pre，next，value

--------------3、字典（map）
redis的底层就是通过字典来实现的
C语言自己实现的struct dictht 作为字典，包含了哈希表数组，哈希表大小，哈希表大小掩码，哈希表节点数

哈希表数组是一个内部实现的 struct dictEntry 的数组，内部实现是个链表
Redis的哈希算法为MurmurHash算法，有点在于，即使输入的键是有规律的
算法也能给一个很好的随机分布性，并且算法的计算速度也很快

哈希冲突的时候，使用链式解决，并且新的值会放到链的头
哈希负载因子太大或者太小的时候，就会rehash，保证哈希负载在一定范围内

开始哈希扩展的条件：
1）服务器没有执行BGSAVE、BGREWRITEAOF 且负载因子大于等于1
2）服务器在执行BGSAVE、BGREWRITEAOF 且负载因子大于等于5
因为上述指令都是会创建写时复制（copyOnWrite），所以会有子进程，尽量避免子进程存在的时候rehash，省去一次写入操作

开始收缩的条件：
1）负载因子小于0.1

渐进式rehash：就是先开一个backup表，然后慢慢往上面写，完了之后再全量切换

--------------------------4、跳表
跳表作为有序集合键（zset）的底层实现之一，实际上就是一种优化后的有序的树
当元素的数量比较多的时候，或者元素的成员是比较长的字段的时候，就会使用跳表

另外在集群节点的内部数据结构也有使用
跳表的结构 struct zskiplist ，包含了头结点、尾结点、最大层数（最长叶子数）、跳表长度（包含节点数）

--------------------------5、整数集合
就是List<Integer>
是集合键的底层实现

升级：新添加一个元素到集合里，并且新元素的类型比现有元素都要长，整数集合就会升级
这样可以省内存

--------------------------6、压缩列表
是列表键和哈希键的底层实现之一，
如果一个列表键 或者哈希键 值包含少量项，并且每个项都是小数值、或者短字符串，那就回用压缩列表实现
List<Varchar>的感觉

-------------------------7、对象
redis对所有的数据类型，都封装成了对象系统来进行使用
redis的每个新的键值对，都会创建出来两个对象，一个用作键，一个用作对象

每个对象都是一个redisObject， 包含struct type，encoding，ptr
type表示类型，encoding表示编码，ptr表示指向底层的指针

键总是REDIS_STRING，
值可以为REDIS_STRING 、REDIS_LIST 、REDIS_HASH、REDIS_SET、REDIS_ZSET

称呼一个键为列表键，则表示value为列表，字符串键表示value为string，因为key都是string

字符串对象，可以保存数字，也可以保存字符，是通过encoding实现的，包含int、raw、embstr
数字型的是int
大于32字节的字符串，就会用SDS，就是raw
如果小于等于32字节，就会用embstr，专门用来保存短字符串的优化编码方式

列表对象分为ziplist 和 linkedlist两种，压缩列表和链表 ，小队列用压缩列表，大队列转链表

哈希对象分为ziplist 和 hashtable，压缩列表里面，key value是连在一起的
哈希对象的所有键值长度小于64的时候，且总key少于512的时候，用ziplist，否则hashtable

集合对象分为intset和hashtable，所有元素都是整数，且不超过512时，就是intset，否则hashtable

有序集合对象分为ziplist 和 skiplist，所有元素都小于64字节，且小于128元素，用ziplist 否则 skiplist

------------------------类型检查
redis命令分为两种 
1、可以对任何键执行 ，比如DEL， EXPIRE，RENAME，TYPE，OBJECT
2、只能对特定键执行，比如String类型键，只能用SET

对特定键执行的命令，如果执行了错误类型，会返回一个错误信息

-----------------------对象共享
redis初始化的时候，会创建0-9999的所有整数，类似IntCache，作为缓存，服务器会共享对象
之所以只共享0-9999，是因为字符串的话，需要额外判断是否存在，是否完全相同，复杂性太高

对象会记录最后一次被访问的时间，用于计算对象的空转时间（lru算法会用到？）


----------------------------第二部分、单机数据库的实现 -----------------------------
Redis服务器所有数据库都保存在redisServer结构的db数组内
而服务器内部存在一个redisClient结构的指针，指向当前正在使用的db

读写键时的操作：
1、服务器会维护对键的命中次数和不命中次数
2、读取一个键的时候，就会更新键的LRU（最后一次使用）时间，可以用来计算键的闲置时间
3、如果读取键的时候，发现键已过期，会先过期之后再操作


------------设置键的过期时间
EXPIRE命令-单位秒（SETNX这种类型指令过期原理和EXPIRE一样）
PEXPIRE单位 毫秒

EXPIREAT key 1377257300  这样就是在一个指定的UNIX时间戳过期

TTL可以获取一个键剩余的生存时间（秒） PTTL 获取毫秒
通过计算当前时间戳和过期时间戳之间差值

！！！！！！！实际上底层都是PEXPIREAT来实现的（在某个指定的毫秒unix时间戳过期）
redisDb的结构里面会保存一个expires字典，来保存所有键的过期时间（long类型的毫秒unix时间戳）

PERSIST命令会移除过期时间，实际上就是从expires字典里面把key去掉

---------删除策略：
1、定时删除（通过定时器，在每个键的过期时间触发定时器进行删除）
	对CPU很不友好，对服务器影响大，不显示
2、惰性删除（放任不管，但是每次操作都会判断是否已经过期）
	对CPU友好，但是会造成内存泄露，多占了很多没用的内存，可能过期了但是一直不操作
3、定期删除（每隔一段时间，删除库内所有过期键）
	1、2的折中，但是需要控制好时长和频率，多了就会变成1，少了就会变成2

RDB对过期键的处理：
1、生成RDB文件：执行SAVE、BGSAVE命令创建一个新的RDB文件时，会检查db内的键，已过期的键不会保存到新的RDB文件
2、载入RDB文件：服务器为主，会过滤过期key；服务器为从，会全量载入

AOF对过期键的处理：
1、AOF文件写入：如果key已过期，但是还没删除，AOF就不会动；直到过期DEL之后，AOF也会补一条DEL
2、AOF重写：已过期的键不会被保存到重写后的AOF文件

复制：
1、主服务器删除过期键之后，给所有从服务器发一个DEL命令
2、从服务器在读取的时候，不会主动删除过期键，而是当做没有过期
3、从服务器只有接受到主服务器来的DEL的时候，才会删除过期键


------------------------RDB持久化
由于redis是内存数据库，没法持久化，所以提供了RDB机制进行持久化

RDB文件是一个经过压缩的二进制文件，该文件可以还原成RDB文件当时的数据库状态
RDB文件是保存在硬盘里的，所以即使服务中断，只要文件还在，就可以还原

持久化命令有两种，SAVE和BGSAVE（BackGroundSave）
SAVE会阻塞redis进程，直到创建完RDB文件；
BGSAVE 会通过fork派生出一个子进程，然后由子进程去创建RDB文件

RDB文件的载入是服务器启动的时候自动执行的（只要检测到RDB文件，就会自动载入）
执行log：DB loaded from disk
没有专门执行载入RDB文件的命令

因为AOF文件的更新频率通常会比RDB高，所以：
1、如果开启了AOF，会优先使用AOF恢复数据
2、只有AOF关闭时，才会用RDB

在BGSAVE执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF命令和平时不一样：
1、SAVE会被禁止，是为了防止服务器进程和子进程同时进行RDB save，产生竞争
2、BGSAVE也会被拒绝，因为防止竞争
3、如果BGSAVE再执行，BGREWRITEAOF会等待BGSAVE结束；
     如果BGREWRITEAOF在执行，BGSAVE会被拒绝
     虽然两个子进程没有什么影响，但是两个进程同时大量磁盘操作，会影响性能

服务器开启自动BGSAVE命令：
save 900 1
save 300 10
save 60 10000
满足900秒修改了一次数据库、300秒修改了10次、60秒修改了10000次，就会执行BGSAVE

以下的SAVE包括SAVE和BGSAVE：
配置：
strucrt saveparams{
second;  //描述
changes;  //修改数
}

redisServer里面有两个字段：dirty记录上次SAVE之后，服务器进行了多少次修改;lastSave记录服务器上次SAVE的时间
struct redisServer{
dirty;      //修改计数器
lastSave;  //上次SAVE的时间
}

然后通过定时任务去校验是否满足条件，如果满足了就BGSAVE一次，然后清空


---------------------AOF持久化（类似binlog）
AOF打开时，服务器每执行完一个命令，都会加到服务器状态的aof_buf缓冲区的末尾，多一行

AOF文件分为内存缓冲区和磁盘文件，
WRITE：把内容从aof缓存写入AOF文件（即内存缓冲区），并且此时内容都在缓存中，还没有落磁盘
SYNC: 把AOF文件的缓冲区内容写入磁盘

redis.conf有个配置：flushAppendOnlyFile，always全部同步磁盘，everysec每秒同步一次（默认）, no看操作系统心情

所以这里会存在一个时间窗口，如果缓存期间宕机就会丢数据，所以如果要求很高的就要FSYNC（直接同步）
FSYNC和FDATASYNC区别：FSYNC会把打开文件的所有信息都写进去，包括一些元数据，FDATASYNC只写数据
FDATASYNC会少同步一些比如（atime、mtime）的元数据，对读写没影响，但是会提高性能

---------------AOF文件的还原：
1、创建一个不带网络连接的伪客户端
2、从AOF文件读取写命令
3、使用伪客户端执行命令，直到写入完毕

---------------AOF重写：
每过一段时间，AOF会创建一份新的AOF文件，并且把多条可合并的命令合并起来
RERWRITEAOF 和 BGREWRITEAOF

对同一个key的多条读写，可以简化为直接从数据库中读取到的当前的值就行了
感觉像基于RDB实现的AOF

AOF直接重写（REWRITEAOF）会阻塞网络连接
AOF后台写入（BGREWRITEAOF）虽然可以并行，但是存在并发问题，所以会建一个AOF重写缓冲区
	AOF重写的过程中：
	1、主进程先执行客户端发来的命令
	2、将写指令追加到AOF缓冲区（定期write and sync到AOF文件）
	3、将写指令追加到AOF重写缓冲区（作用于重写进程）
重写完成的过程为：先跑原先AOF的内容，然后跑AOF重写缓冲区的内容，然后rename，就完成了AOF文件的替重写


------------------------------------事件----------------------------------
redis分为两类事件：
文件事件（指令处理）和时间事件（定时任务）


-----------文件事件
redis有自己的文件事件处理器，用I/O多路复用来同时监听多个套接字，并根据套接字执行的任务关联不同的事件处理器
虽然是单线程，但是通过IO多路复用可以保证高性能

文件事件处理器分为4部分：
1、套接字（socket与外部进行网络连接和传输，netty）
2、IO多路复用（监听和执行）
3、文件事件分发器（队列）
4、事件处理器（命令请求回复器、命令回复处理器、连接应答处理器等）

出现并发的情况，IO多路复用会监听多个套接字，并向派发器串行传送信息（队列入队）
IO多路复用的功能都是通过select，epoll，evport和kqueue这些IO多路复用函数库实现的（linux内核自带）
具体用哪个看操作系统，会自动选择

事件处理器：
1、连接应答处理器（客户端会先连接，但是什么都不干）：用于对监听套接字的客户端进行应答，告诉客户端收到连接了
	每当客户端连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，
	然后连接应答处理器就会去套接字执行应答操作
	连接上了之后，服务器会将套接字的AE_READABLE事件和命令请求处理器关联起来（分配一个客服？）
2、命令请求处理器：客户端发命令请求时，就会有专属命令请求处理器从套接字执行读取命令操作（专属客服为您服务？）
	直到连接关闭
3、命令回复处理器：在请求的命令在redis服务器执行完了之后，通过命令回复处理器将执行之后的命令通过套接字返回客户端，
	当有命令回复需要给客户端时，会将套接字的AE_WRITABLE事件和命令回复处理器关联（分配专属物流）
	当客户端准备好接受命令回复时，就会产生AE_WRITABLE事件，然后命令回复处理器就会执行写入操作
	发送完毕之后，就会接触命令回复处理器和AE_WRITABLE事件的连接（快递送到了）

服务器处理时间的流程：
轮询->等待事件产生->处理文件事件（非定时事件）->处理已到达的时间事件->结束->轮询
事件处理都是串行有序的，不会中途中断，只有部分耗时操作会后台执行，BGXXXX，
实际上要有文件事件，才会跟着处理时间事件

----------------------------客户端
每个与服务器连接的客户端，redis服务器都建立了RedisClient结构，并保存了：
1、套接字
2、客户端名字
3、客户端标志值flag
4、客户端连接的数据库的号码和指针
5、客户端当前执行的命令、参数、参数个数、指向函数信息
6、客户端的输出缓冲区、输入缓冲区
7、客户端复制状态信息、复制所需的数据结构
8、客户端事务的状态
9、发布、订阅信息
10、身份验证标志
11、创建时间、最后一次通信时间、输出缓冲区大小超出限制的时间

redis服务器上有flag作为标志
类似REDIS_MASTER 
REDIS_SLAVE | REDIS_PRE_PSYNC | REDIS_FORCE_AOF

REDIS正常AOF只会记录对数据库修改的指令，但是PUBSUB（广播推送订阅）会修改客户端状态
所以会被REDIS_FORCE_AOF标志强制写入AOF文件
SCRIPT LOAD命令也是一样，载入脚本，同时还需要REDIS_FORCE_REPL标志，将所有的从服务器也强制执行脚本
一般只有伪客户端才会标记这些，伪客户端表示专门用于执行lua脚本或恢复AOF信息载入的客户端，并非真实连接

lua脚本执行的伪客户端在服务器启动的时候就会存在，直到服务器被关闭

客户端关闭的原因有:
1、网络连接关闭
2、发送了不合协议的命令请求
3、成为client kill命令的目标
4、空转时间超时
5、输出缓冲区的大小超出限制

------------------------------服务器
命令请求的执行过程
1、客户端像服务器发送命令请求
2、服务器接受并处理请求，在数据库中进行对应操作，并产生命令回复OK
3、服务器将命令回复OK发送给客户端
4、客户端接受命令回复OK，并告知用户

1）发送命令请求
客户端发送请求时，会将这个命令请求转换成协议格式，然后连接到redis服务器的套接字，将协议格式的请求发给服务器

2）读取命令请求
1、套接字变为可读READABLE，事件分发器队列开始调用事件处理器。
2、服务器调用命令请求处理器，读取套接字中协议格式的命令请求，并保存到客户端状态的输入缓冲区中
3、分析输入缓冲区的命令请求，提取出命令请求中包含的参数和参数个数，存在客户端状态的argv和argc中
4、调用命令执行器，执行指定命令

PSUBSCRIBE test* 可以匹配test开头的所有频道（pattern subscribe 匹配符订阅）

3）命令执行器：
1、查找命令的实现方法：
	根据客户端状态的argv[0]参数（实际上就是方法名）在命令表中查找参数指定的命令，并保存到客户端的cmd属性
	命令表就是一个命令名->实现方法指针的map（相当于一个Function<T,R>）
	比如set命令，就会找到setCommand方法的方法指针
2、执行预备操作：
	检查客户端状态的cmd指针是否null，null表示不存在命令，直接报错返回
	检查命令的参数个数是否正确，错误直接报错返回
	检查客户端是否已经通过身份验证，未验证客户端只能执行AUTH命令
	如果服务器开了maxmemory功能，在执行前先检查内存占用情况，内存不足报错返回
	如果服务器上一次BGSAVE失败，并且服务器开了stop-writes-on-bgsave-error，并且是个写命令，会拒绝执行并报错返回
	如果客户端当前正在用SUBSCRIBE订阅，或正在用PSUBSCRIBE命令订阅模式，那服务器指挥执行客户端的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE
	如果服务器正在进行数据载入，那么服务器只会执行l标志的命令 比如INFO、SHUTDOWN、PUBLISH这些
	如果服务器因为执行Lua脚本阻塞，那么只会执行SHUTDOWN nosave和SCRIPT KILL
	如果客户端正在执行事务，那么服务器只会执行EXEC、DISCARD、MULTI、WATCH，其他都会被放入事务队列
	如果服务器开启了监视器功能，那么会将执行的命令和参数发送给监视器
3、调用命令的实现函数
	服务器执行client->cmd->proc(client) 相当于调用方法指针
	实现函数执行操作之后，产生相应的命令回复，并保存到服务器的客户端状态的输出缓冲区
	实现函数为客户端的套接字关联命令回复处理器（负责将命令回复返回给客户端）
4、执行后续工作
	如果开启了慢查日志，判断是否慢查并记录
	更新被执行命令的command结构的millisecond，并将call计数器+1
	如果开启了AOF，会将执行命令写入到AOF缓冲区
	如果有主从，将命令传播给从服务器
	服务器对当前命令执行结束，然后服务器可以继续从文件事件处理器（队列）取出并处理下个请求了
5、将命令回复给客户端
	关联命令回复处理器之后，当套接字变为可写时，服务器将输出缓冲区的命令回复发送给客户端
6、客户端接受回复并打印


服务器有一个LRU时钟，同时每个Redis对象都有一个lru属性，记录对象最后一次被访问的时间
当服务器要计算数据库的空转时间时，用lru时钟的值减去对象的lru时间，就是对象的空转时间

服务器执行BGSAVE的期间，如果发来了BGREWRITEAOF命令，那么会延迟到BGSAVE完成后

服务器从启动到能够执行命令的步骤
1、初始化服务器状态
2、载入服务器配置
3、初始化服务器数据结构
4、还原数据库状态
5、开始执行事件循环


----------------------------第三部分、多机数据库的实现 -----------------------------
------------------复制
redis的复制分为同步和命令传播
1、同步用于将备库的数据库状态更新为主库的数据库状态
2、命令传播用于主库状态修改时，将主从回到同一状态

同步：
客户端发送SLAVEOF的时候，主库BGSAVE，生成一个RDB文件，然后把文件发送给从服务器，
从服务器开始更新RDB的数据状态

命令传播：
后续命令的同步，主库执行的命令从库再执行一遍

从库掉线后，SYNC很费性能，redis2.8之后支持了PSYNC，具有完整重同步和部分重同步两种模式
1、完整重同步等于SYNC
2、部分重同步会将服务器掉线期间的命令重跑一遍，而不整个sync

---创建主从的过程：
1、设置主服务器的地址和端口，在从服务器的服务器信息中保存
2、建立套接字连接，从服务器同时具备服务器和客户端两个身份，可以理解为从服务器是主服务器的客户端
3、发起PING命令，PING一下主服务器，不停断开重试直到返回PONG
4、身份验证，进行服务器auth
5、发送端口信息
6、同步（全量）
7、开始命令传播（增量）

连接建立完成之后，会进行心跳检测，从服务器向主服武器发送命令，告知偏移量和连接状态

-------------------哨兵Sentinel



----------------------------第四部分、独立功能的实现 -----------------------------


















