---------适配器模式 
将一个接口转换成客户端的一个借口
关系：适配接口和被适配接口没有层次关系  （就是说两个不同的东西，没有上下级）
java AWT， java IO， Spring Web  MVC


---------装饰器模式（都是通过继承来实现的）
动态添加或覆盖被包装者的行为
关系：装饰者和被装饰者有层次关系
例子： javaIO， SpringCore， SpringWebMVC

装饰器和适配器区别在，适配器的两者是无关的，一个东西转成另一个东西
而装饰器是有关系的两个，比如父类被装饰成子类

简单的说，装饰器就是，苹果是一种水果， 适配器就是，苹果被适配成了货物

--------享元模式
共享状态对象，减少重复创建
关系：享元对象缓存共享实体
例子：Integer 缓存，String Intern ，Thread Local
String.intern() ，把创建出来的堆里面的字符串变量，放到字符串常量池里面

ThreadLocal ，里面有个ThreadLocalMap的用法，
实际实现是类似一个Map<Thread, ThreadLocalMap>的东西，每个线程存放一个变量map
这个ThreadLocalMap是一个享元模式的map，里面的对象就是提前创建，用于同个线程共享

线程池，数据库连接池，对象池都是
共同点就是创建起来麻烦，而且通用


-----------组合模式（可以是一对多）
执行组合对象时如同执行其元素对象
特点：组合对象和被组合对象可能是相同类型
例子： SpringCache ， SpringWebMVC

比如有A1，A2，A3是同一种东西的不同对象，然后有一个A对象
里面有A1，A2，A3三种类型的字段，
A的方法可以包含三种字段的操作，直接执行A的方法，就相当于执行了A1， A2， A3的方法
就是类自己的字段里面，有类实现的类的内容，而使用者只需要关注组合的类，不需要关注实现
具体实现可以往组合类里面添加

SpringCache 里面有个CompositeCacheManager 实现了CacheManager
然后里面有个List<CacheManager> 

--------------代理模式
和组合有点相似，但是代理是一对一的
使用者不直接接触实现，通过代理去调用实现


--------------门面模式
简化接口，聚合子系统实现
组合对象和被组合对象是相同类型
门面接口和子系统接口自动组合实现
例子： Tomcat，DispatchServlet实现的一系列过程

就是service把不同dao的逻辑组合起来，把相对独立的操作给聚合起来
并且实现细节的处理

会有一个问题，因为要大量实现，所以要大量入参，对实现并不友好

--------------桥接模式
通过一个外部接口，桥接到具体的内部实现

扫码购物，扫码了之后，会跳转到具体的京东扫码购物里面，或者淘宝扫码购物里面

实现是通过把具体的服务service都注入，然后根据扫码购物接口的判断
判断是具体使用哪个注入的服务的实现方法

也就是说，扫码购物接口里面，具体的逻辑都是用的interface和interface自带的方法
具体实现调用的implement了 interface的方法的接口，
依赖于具体注入（构造器）了那个实现方法

外面都是掉的相同的方法，怎么实现就看丢进去什么东西

桥接模式的好处是：对应客户端而言，只关注粗粒度接口，具体执行方法
只根据运行时初始化而定

-------策略模式
需要触发条件的一堆if-else，然后返回不同结果或者进行不同处理的策略；

其实是声明一个接口，接口里面有一个方法
不同的策略类分别实现接口，并且通过自己的策略重写这个方法
在声明的时候，声明成接口，初始化成不同的策略类，即可；







