HashMap 
 底层使用数组 + 链表实现， java1.8里面，如果链表过长，会将链表转化成红黑树实现
				复杂度位O（logn）
求hash值的方法
1、key.hashCode()方法得到hashcode，然后高16bit和低16bit进行异或，为了保证低位均匀性
     就是说，原来的高16位，保持原来的样子，但是低16位，就变成了原先低16位和原先高16位的异或
     就是为了混合原始哈希码的高位和低位，以此来加大低位随机性
2、然后得到的hash值 （n-1）& hash，就是只保留低位，相当于hash%n，取余操作

put方法
1、对key求hash值，计算数组的下标
2、如果没有碰撞，直接放入散列桶内
3、如果碰撞了，用链表的方式链接到后面
4、如果链表的长度超过阈值（TREEIFY_THRESHOLD = 8）,就把链表转换成红黑树（java8）
5、遍历链表，如果节点已经存在就替换旧值
6、如果桶满了（达到了容量*加载因子），就执行resize操作（）

HashMap解决冲突，扩充过程
1、如果hash下标对应的链表已经存在，将新节点加到链表之后
2、扩容的时候，将容量扩充到原来的两倍，然后对数组里面，每个链表的每个节点重新计算hash下标值
3、这个值只可能在两个地方，一个是原来下标的位置，一个是在下标为<原下标+原容量>的位置

抛开HashMap，hash冲突的解决方法
1、开放定址
2、链地址法



